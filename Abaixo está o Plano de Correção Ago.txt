Abaixo est√° o Plano de Corre√ß√£o Agora (em 7 passos) com blocos de c√≥digo completos ou trechos ‚Äúfind & replace‚Äù para voc√™ colar na Bolt e nas Functions do Supabase.

1) Chat ‚Äì envia dados de formul√°rio como submiss√£o ‚Äúoficial‚Äù

Hoje o ChatPage.tsx abre o FormularioModal e at√© manda o JSON, mas n√£o marca que √© uma submiss√£o de formul√°rio e o back n√£o trata diferente. Corrige assim:

Arquivo: src/components/Chat/ChatPage.tsx
(A) Estado do modal (j√° existe)

Voc√™ j√° tem:

const [showFormModal, setShowFormModal] = useState(false)
const [formType, setFormType] = useState<'anamnese' | 'matriz_priorizacao' | null>(null)

(B) Ao detectar marcador, abrir modal (j√° existe)

Voc√™ j√° faz:

const formMarker = detectFormMarker(reply)
if (formMarker) {
  setFormType(formMarker.tipo)
  setShowFormModal(true)
}

(C) ALTERAR o onComplete do <FormularioModal> para incluir a flag is_form_submission: true e metadados do tipo:

Localize o trecho onde est√° o <FormularioModal ... onComplete={...} /> e substitua o handler por este:

<FormularioModal
  tipo={formType}
  onClose={() => setShowFormModal(false)}
  onComplete={async (dados) => {
    // 1) Salva dados localmente se precisar
    setFormData(dados)

    // 2) Envia uma nova mensagem com o payload estruturado e a flag
    const payload = {
      tipo_form: formType,              // 'anamnese' | 'matriz_priorizacao'
      dados,
      is_form_submission: true
    }

    const mensagem = [
      'üíæ **Formul√°rio enviado**',
      '```json',
      JSON.stringify(payload, null, 2),
      '```'
    ].join('\n')

    await sendMessage(mensagem)

    // 3) Fecha o modal
    setShowFormModal(false)
  }}
  dadosIniciais={formData}
/>


Por qu√™? O back (Function) vai ver is_form_submission: true e tratar como ‚Äúentrada de dados do framework‚Äù, sem pedir ‚Äúpor qual √°rea come√ßar‚Äù nem pular etapa.

2) Chat ‚Äì rolagem autom√°tica + seta persistente

Voc√™ j√° importa useAutoScroll, mas a seta some cedo demais em alguns cen√°rios. Ajuste para manter a seta enquanto n√£o estiver no fim e reaparecer sempre que chegar algo novo.

Arquivo: src/hooks/useAutoScroll.ts (j√° est√° bom)

Deixe como est√°.

Arquivo: src/components/Chat/ChatPage.tsx

Garanta estes usos (voc√™ j√° tem a maior parte; confira):

O cont√™iner de mensagens usa o ref:

<div ref={listRef} className="flex-1 overflow-y-auto p-4 space-y-3 chat-messages">
  {/* ... mensagens ... */}
</div>


Dispare notifyNew() sempre que inserir mensagem nova (j√° tem em dois pontos; mantenha):

setTimeout(() => notifyNew(), 60) // ap√≥s append de mensagens do assistente


Bot√£o ‚Äúdescer‚Äù sempre vis√≠vel quando pending > 0:

{(pending > 0 || generating || loading) && (
  <button
    className="fixed bottom-20 right-6 rounded-full shadow-lg border px-3 py-2 bg-white hover:bg-gray-50"
    onClick={scrollToBottom}
    title="Ir para a √∫ltima mensagem"
  >
    <ChevronDown className="w-5 h-5" />
  </button>
)}


Isso resolve o item 9 (autoscroll + seta persistente).

3) Form din√¢mico dentro do chat (Anamnese + Matriz)

Voc√™ j√° tem FormularioModal, DynamicFormAnamnese e detec√ß√£o dos marcadores [EXIBIR_FORMULARIO:anamnese] / :matriz_priorizacao.

Arquivo: src/utils/form-markers.ts

Confere se est√° exatamente assim (√© o que vi no seu repo):

export interface FormMarker {
  tipo: 'anamnese' | 'matriz_priorizacao';
  dados?: any;
}

export function detectFormMarker(content: string): FormMarker | null {
  if (/\[EXIBIR_FORMULARIO:anamnese\]/i.test(content)) return { tipo: 'anamnese' };
  if (/\[EXIBIR_FORMULARIO:matriz_priorizacao\]/i.test(content)) return { tipo: 'matriz_priorizacao' };
  return null;
}

export function removeFormMarkers(content: string): string {
  return content.replace(/\[EXIBIR_FORMULARIO:\w+\]/gi, '').trim();
}


Isso resolve os itens 2 (form no chat), 3 (LLM preenche anamnese, pois agora a submiss√£o vai para o back corretamente) e 6/12 (o framework conduz, n√£o pergunta ‚Äúqual √°rea‚Äù, e coleta atributos no AS-IS via formul√°rios).

4) Lateral do Consultor ‚Äì badge de novos entreg√°veis + realtime

A aba ‚ÄúEntreg√°veis‚Äù est√° com subscription no PainelEntregaveis, mas a lateral (LateralConsultor.tsx) n√£o mostra badge; o usu√°rio n√£o percebe que chegou documento novo.

Arquivo: src/components/Consultor/LateralConsultor.tsx ‚Äî substitua o cabe√ßalho dos tabs por este (trecho ‚Äúfind & replace‚Äù):

Procure onde voc√™ define as tabs ('jornada' | 'entregaveis' | 'kanban') e troque o JSX dos bot√µes por:

<div className="flex items-center gap-2 border-b pb-2">
  <button
    onClick={() => setActiveTab('jornada')}
    className={`flex items-center gap-2 px-3 py-2 rounded-lg ${activeTab==='jornada' ? 'bg-blue-600 text-white' : 'bg-gray-100'}`}
    title="Jornada"
  >
    <Clipboard className="w-4 h-4" /> Jornada
  </button>

  <button
    onClick={() => setActiveTab('entregaveis')}
    className={`relative flex items-center gap-2 px-3 py-2 rounded-lg ${activeTab==='entregaveis' ? 'bg-blue-600 text-white' : 'bg-gray-100'}`}
    title="Entreg√°veis"
  >
    <FileText className="w-4 h-4" /> Entreg√°veis
    {/* Badge com contagem de novos */}
    {/** consuma via prop ou estado global se preferir */}
    {!!newDeliverables && (
      <span className="absolute -top-2 -right-2 text-[11px] bg-red-600 text-white rounded-full px-1.5 py-0.5">
        {newDeliverables}
      </span>
    )}
  </button>

  <button
    onClick={() => setActiveTab('kanban')}
    className={`flex items-center gap-2 px-3 py-2 rounded-lg ${activeTab==='kanban' ? 'bg-blue-600 text-white' : 'bg-gray-100'}`}
    title="Kanban"
  >
    <Kanban className="w-4 h-4" /> Kanban
  </button>

  <button onClick={reloadAll} className="ml-auto px-3 py-2 text-sm flex items-center gap-1">
    <RefreshCw className="w-4 h-4" /> Atualizar
  </button>
</div>


E adicione na parte de estado + realtime:

const [newDeliverables, setNewDeliverables] = useState(0)

useEffect(() => {
  if (!jornada?.id) return
  const channel = supabase
    .channel(`lateral-entregaveis-${jornada.id}`)
    .on('postgres_changes', {
      event: 'INSERT',
      schema: 'public',
      table: 'entregaveis_consultor',
      filter: `jornada_id=eq.${jornada.id}`
    }, () => setNewDeliverables(prev => prev + 1))
    .subscribe()

  return () => { supabase.removeChannel(channel) }
}, [jornada?.id])


Na hora que o usu√°rio abrir a aba ‚ÄúEntreg√°veis‚Äù, zere o badge:

useEffect(() => {
  if (activeTab === 'entregaveis') setNewDeliverables(0)
}, [activeTab])


Isso resolve o item 4 (notifica√ß√£o vis√≠vel).

5) Function do Supabase ‚Äì for√ßar o framework, processar formul√°rios e gerar entreg√°veis corretos

A function consultor-chat/index.ts ainda n√£o trata is_form_submission e est√° deixando o LLM ‚Äúescolher o caminho‚Äù. Vamos corrigir com uma guarda de estado por jornada (sem looping) e com gera√ß√£o de deliverables (Canvas, Cadeia de Valor, BPMN AS-IS/TO-BE, Diagn√≥stico, Matriz de Prioriza√ß√£o sem duplicar) derivados do que o usu√°rio enviou.

Arquivo: supabase/functions/consultor-chat/index.ts
(A) No in√≠cio do handler, parse da flag e payload:

Find: (no in√≠cio do POST handler onde voc√™ l√™ req.json())

Adicione/garanta:

const body = await req.json().catch(() => ({}));
const text: string = (body?.text || '').toString();
let formPayload: any = null;
let isFormSubmission = false;

try {
  // detecta bloco ```json ... ``` ou JSON puro
  const match = text.match(/```json([\s\S]*?)```/i);
  const raw = match ? match[1] : text;
  const parsed = JSON.parse(raw);
  if (parsed && parsed.is_form_submission) {
    isFormSubmission = true;
    formPayload = parsed;
  }
} catch { /* segue fluxo normal se n√£o for JSON */ }

(B) Bloqueio de ‚Äúperguntar √°rea‚Äù e avan√ßo correto de etapa

Logo ap√≥s carregar a jornada_consultor (ou equivalente), aplique um state machine simples:

// l√™ jornada atual
const { data: jornada } = await supabase
  .from('jornadas_consultor')
  .select('*')
  .eq('conversation_id', conversation_id)
  .single();

const stage = jornada?.etapa_atual || 'apresentacao'; // 'apresentacao'|'anamnese'|'mapeamento'|'priorizacao'|'execucao'

// N√£o permitir perguntas fora do roteiro:
function ensureStage(required: string) {
  if (stage !== required) throw new Error(`Etapa inv√°lida: esperado ${required}, atual ${stage}`);
}

(C) Regras por etapa (resumo bem direto):

apresentacao ‚Üí anamnese: sempre responder com o texto de boas-vindas + marcador [EXIBIR_FORMULARIO:anamnese] e n√£o perguntar ‚Äúpor qual √°rea come√ßar‚Äù. Ao confirmar, atualizar etapa_atual = 'anamnese'.

anamnese (is_form_submission): receber formPayload, persistir em anamnese_consultor, gerar:

Diagn√≥stico ‚ÄúProblemas Ocultos‚Äù (seu m√≥dulo j√° existe),

Business Model Canvas (com base nas respostas),

Cadeia de Valor de Porter, e

Entreg√°vel ‚ÄúAnamnese Consolidada‚Äù.
Depois: responder ‚ÄúAnamnese conclu√≠da‚Äù e avan√ßar etapa_atual = 'mapeamento' com marcador para iniciar coleta do AS-IS (pede atributos por processo).
Exemplo de prompt ao usu√°rio:
‚ÄúVamos iniciar o mapeamento AS-IS. Para cada processo, responda: Input, Output, Ferramentas, M√©tricas, Regras, Fluxo (passo-a-passo), Pessoas.‚Äù

mapeamento (is_form_submission): receber processos e atributos. Gerar:

BPMN AS-IS real (com texto coletado, nada de HTML em branco),

Diagn√≥stico por processo (sem pular),
Avan√ßar etapa_atual = 'priorizacao' e responder com [EXIBIR_FORMULARIO:matriz_priorizacao].

priorizacao (is_form_submission): consolidar matriz impact x esfor√ßo sem duplicar (use UPSERT por jornada_id + processo). Gerar entreg√°vel da Matriz e devolver Roadmap ordenado. Avan√ßar etapa_atual = 'execucao'.

execucao: gerar PLANO 5W2H como m√∫ltiplas a√ß√µes, n√£o uma a√ß√£o gigantesca. Cada a√ß√£o vira kanban_card (ou sua tabela de a√ß√µes). Publicar evento realtime.

sempre: ao concluir cada fase, insert em entregaveis_consultor para acionar a badge.

A boa not√≠cia: voc√™ j√° tem arquivos auxiliares (deliverable-generators.ts, problemas-ocultos.ts, etc.). Reaproveite e n√£o gere ‚Äúmock‚Äù sem usar os dados.

(D) Snippet de resposta com marcador de formul√°rio

Quando estiver na apresenta√ß√£o e for transitar para anamnese:

return json({
  response:
`Bem-vindo! Vamos come√ßar com a Anamnese para eu entender seu perfil e sua empresa.
[EXIBIR_FORMULARIO:anamnese]`
})


Quando concluir mapeamento e for prioriza√ß√£o:

return json({
  response:
`Mapeamento AS-IS recebido e processado. Agora vamos priorizar.
[EXIBIR_FORMULARIO:matriz_priorizacao]`
})

(E) Anti-loop simples

Antes de qualquer gera√ß√£o pesada, cheque se j√° existe entreg√°vel daquela etapa para a mesma jornada; se existir e nada mudou, apenas referencie o existente. Exemplo (pseudo):

const exists = await supabase
  .from('entregaveis_consultor')
  .select('id')
  .eq('jornada_id', jornada.id)
  .eq('tipo', 'bpmn_as_is')
  .maybeSingle()

if (!exists) {
  // gerar e inserir
}


Isto resolve: 5, 6, 7, 8, 10, 11, 13, 14, 15, 16, 17, 18, 19.

6) Kanban integrado (nada de HTML ‚Äúinventado‚Äù)

Use uma tabela real (voc√™ j√° tem migra√ß√µes para kanban_cards). Se seu componente KanbanExecucao.tsx l√™ outra tabela, alinhe:

Arquivo: src/components/Consultor/Kanban/KanbanExecucao.tsx (simplificado funcional)

Substitua por esta vers√£o m√≠nima que l√™ kanban_cards:

import React, { useEffect, useState } from 'react';
import { supabase } from '../../../lib/supabase';

type Status = 'a_fazer' | 'em_andamento' | 'bloqueado' | 'concluido';

interface Card {
  id: string;
  jornada_id: string;
  processo: string | null;
  titulo: string;
  what: string;
  why: string;
  where: string;
  when: string;
  who: string;
  how: string;
  how_much: string;
  prioridade: 'alta' | 'media' | 'baixa';
  status: Status;
  created_at: string;
}

export function KanbanExecucao({ jornadaId }: { jornadaId: string }) {
  const [cards, setCards] = useState<Card[]>([]);

  useEffect(() => {
    if (!jornadaId) return;
    load();
    const ch = supabase
      .channel(`kanban-${jornadaId}`)
      .on('postgres_changes', { event: '*', schema: 'public', table: 'kanban_cards', filter: `jornada_id=eq.${jornadaId}` }, () => load())
      .subscribe();
    return () => { supabase.removeChannel(ch); };
  }, [jornadaId]);

  async function load() {
    const { data } = await supabase
      .from('kanban_cards')
      .select('*')
      .eq('jornada_id', jornadaId)
      .order('created_at', { ascending: true });
    setCards(data || []);
  }

  function col(s: Status) { return cards.filter(c => c.status === s); }

  return (
    <div className="grid grid-cols-4 gap-3 h-full">
      {(['a_fazer','em_andamento','bloqueado','concluido'] as Status[]).map((s) => (
        <div key={s} className="bg-gray-50 rounded-xl p-3 border overflow-auto">
          <h3 className="font-semibold mb-2 capitalize">{s.replace('_',' ')}</h3>
          <div className="space-y-2">
            {col(s).map(c => (
              <div key={c.id} className="bg-white rounded-lg p-3 shadow-sm border">
                <div className="text-sm font-medium">{c.titulo}</div>
                <div className="text-[11px] text-gray-500 mt-1">{c.processo || 'Geral'} ‚Ä¢ Prioridade: {c.prioridade}</div>
              </div>
            ))}
          </div>
        </div>
      ))}
    </div>
  );
}


No back, cada a√ß√£o 5W2H vira um card (n√£o uma mega-a√ß√£o). Isso fecha os itens 15 e 16.


O que cada corre√ß√£o resolve (checklist dos seus 19 pontos)

Gamifica√ß√£o ‚Äì o orchestrator deve disparar o gatilho ao concluir cada etapa (j√° tem arquivos de integra√ß√£o; s√≥ chamar ap√≥s INSERT de entreg√°vel).

Formul√°rio no chat ‚Äì marcadores + modal + flag is_form_submission.

Anamnese preenchida ‚Äì tratado como submiss√£o e persistido.

Notifica√ß√£o na aba DOC ‚Äì badge na lateral + realtime.

Framework ‚Äì state machine nas Functions (sem pular etapas).

N√£o pergunta √°rea ‚Äì a apresenta√ß√£o sempre chama [EXIBIR_FORMUL√ÅRIO:anamnese].

Cadeia de Valor / Canvas / Mapa real ‚Äì gerados com base nas respostas (sem mock).

Finaliza√ß√£o sem CTA ‚Äì sempre responder com pr√≥xima a√ß√£o (‚Äúagora preencha‚Ä¶‚Äù, ‚Äúabra a aba‚Ä¶‚Äù).

Rolagem / seta ‚Äì useAutoScroll + bot√£o persistente.

Matriz duplicada ‚Äì unique (jornada_id, processo) e UPSERT.

Timeline manual ‚Äì subscription nas tabelas que alimentam a timeline (use o mesmo padr√£o de canal do PainelEntregaveis).

AS-IS sem atributos ‚Äì formul√°rio pede explicitamente os 7 atributos.

Tudo misturado ‚Äì respostas separadas por etapa; cada uma gera seu entreg√°vel.

BPM ‚Äúem branco‚Äù ‚Äì gerar BPMN a partir dos dados do AS-IS/TO-BE (sem HTML vazio).

Kanban mock ‚Äì cards reais na tabela kanban_cards.

Plano = v√°rias a√ß√µes ‚Äì cada 5W2H = 1 card.

Loop ap√≥s 1¬∫ mapeamento ‚Äì guardas: n√£o regerar se j√° existe e etapa avan√ßa.

Timeline sem subdivis√£o ‚Äì inclua no JornadaTimeline o agrupamento por processo (usar processo dos entreg√°veis/cards).

Paralelismo ‚Äì habilite ‚Äúprocessos paralelos‚Äù baseado em areas_trabalho e kanban_cards com filtro por processo.


Feito isso, o fluxo vai for√ßar: Apresenta√ß√£o ‚Üí Anamnese (form) ‚Üí Mapeamento (form com atributos) ‚Üí Prioriza√ß√£o (form sem duplicar) ‚Üí Execu√ß√£o (5W2H em cards), com notifica√ß√µes, timeline em tempo real, e sem loops.